import type { Cell } from './types'

/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SCORING — функции оценки позиций для размещения грузов
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Алгоритм поиска позиции генерирует кандидатов и оценивает их через scoring.
 * Чем МЕНЬШЕ score — тем ЛУЧШЕ позиция (минимизация).
 *
 * Два режима:
 * - uniform: равномерное распределение (для баланса веса)
 * - dense: плотная укладка (для максимизации заполнения)
 */

/**
 * Весовые коэффициенты для лексикографической сортировки.
 *
 * Используем большие множители для имитации лексикографического сравнения:
 * PRIMARY всегда важнее SECONDARY, SECONDARY всегда важнее TERTIARY.
 *
 * Пример: позиция с z=1, variance=100, gap=999
 *         score = 1*1_000_000 + 100*1_000 + 999 = 1_100_999
 *
 *         позиция с z=2, variance=0, gap=0
 *         score = 2*1_000_000 + 0 + 0 = 2_000_000
 *
 *         Первая позиция лучше (меньше score), несмотря на variance и gap.
 */
const SCORE_WEIGHTS = {
    PRIMARY: 1_000_000,
    SECONDARY: 1_000,
    TERTIARY: 1,
} as const

/**
 * Метрики поверхности под грузом.
 *
 * @param cells - ячейки HeightMap под грузом
 * @param z - высота размещения (верх поверхности)
 *
 * @returns variance - перепад высот поверхности (max - min)
 *                     Показывает неровность. 0 = идеально ровная поверхность.
 *
 * @returns gap - суммарный воздушный зазор под грузом
 *                Сумма (z - height) для каждой ячейки.
 *                0 = груз плотно лежит на поверхности.
 *
 * Визуализация:
 * ```
 *     ┌─────────────┐  ← z = 3 (высота размещения)
 *     │   ГРУЗ      │
 *     └─────────────┘
 *       ↑   ↑   ↑
 *       1   2   1      ← gap по ячейкам: (3-2)=1, (3-1)=2, (3-2)=1
 *     ┌─┐ ┌───┐ ┌─┐
 *     │ │ │   │ │ │    ← существующие грузы с высотами 2, 1, 2
 *     │ │ │   │ │ │
 *     └─┴─┴───┴─┴─┘
 *
 *     variance = 2 - 1 = 1
 *     gap = 1 + 2 + 1 = 4
 * ```
 */
function surfaceMetrics(cells: Cell[], z: number): { variance: number; gap: number } {
    let min = Infinity
    let max = -Infinity
    let gap = 0

    for (const cell of cells) {
        min = Math.min(min, cell.height)
        max = Math.max(max, cell.height)
        gap += z - cell.height
    }

    return {
        variance: max - min,
        gap,
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UNIFORM MODE — равномерное распределение
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Цель: распределить грузы равномерно по площади контейнера.
 * Применение: когда важен баланс веса (например, для транспортировки).
 *
 * Приоритеты (по убыванию важности):
 * 1. z (высота) → предпочитаем низкие позиции
 * 2. variance → предпочитаем ровную поверхность
 * 3. gap → предпочитаем меньше воздушных зазоров
 *
 * Формула:
 *   score = z × PRIMARY + variance × SECONDARY + gap × TERTIARY
 *
 * Пример выбора:
 * ```
 *   Позиция A: z=0, variance=0, gap=0  → score = 0
 *   Позиция B: z=2, variance=0, gap=0  → score = 2_000_000
 *
 *   Выбираем A (на полу), даже если B тоже валидна.
 * ```
 */
export function scoreUniform(cells: Cell[], z: number): number {
    const { variance, gap } = surfaceMetrics(cells, z)

    return (
        z * SCORE_WEIGHTS.PRIMARY +
        variance * SCORE_WEIGHTS.SECONDARY +
        gap * SCORE_WEIGHTS.TERTIARY
    )
}

/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DENSE MODE — плотная укладка
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Цель: максимально плотно заполнить контейнер снизу вверх.
 * Применение: когда важна максимизация загрузки.
 *
 * Приоритеты (по убыванию важности):
 * 1. -z (отрицательная высота) → предпочитаем ВЫСОКИЕ позиции (стекинг)
 * 2. gap → предпочитаем меньше воздушных зазоров
 * 3. variance → предпочитаем ровную поверхность
 *
 * Формула:
 *   score = -z × PRIMARY + gap × SECONDARY + variance × TERTIARY
 *
 * Пример выбора:
 * ```
 *   Позиция A: z=0 (пол)           → score = 0
 *   Позиция B: z=2 (на другом грузе) → score = -2_000_000
 *
 *   Выбираем B (стекинг), т.к. score меньше.
 *   Это заполняет контейнер снизу вверх, минимизируя пустоты.
 * ```
 *
 * Почему -z?
 *   В режиме минимизации (меньше = лучше) отрицательный z
 *   означает предпочтение высоких позиций.
 */
export function scoreDense(cells: Cell[], z: number): number {
    const { variance, gap } = surfaceMetrics(cells, z)

    return (
        -z * SCORE_WEIGHTS.PRIMARY +
        gap * SCORE_WEIGHTS.SECONDARY +
        variance * SCORE_WEIGHTS.TERTIARY
    )
}
